use std::os::raw::*;
/* automatically generated by rust-bindgen */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ID_NONE: u32 = 0;
pub const TimeNone: u32 = 0;
pub const HwidNone: u32 = 0;
pub const AddrNone: i32 = -1;
pub const ImplNone: u32 = 0;
pub const WaitIdNone: u32 = 0;
pub const ompd_segment_none: u32 = 0;
pub type __u_char = c_uchar;
pub type __u_short = c_ushort;
pub type __u_int = c_uint;
pub type __u_long = c_ulong;
pub type __int8_t = c_schar;
pub type __uint8_t = c_uchar;
pub type __int16_t = c_short;
pub type __uint16_t = c_ushort;
pub type __int32_t = c_int;
pub type __uint32_t = c_uint;
pub type __int64_t = c_long;
pub type __uint64_t = c_ulong;
pub type __quad_t = c_long;
pub type __u_quad_t = c_ulong;
pub type __intmax_t = c_long;
pub type __uintmax_t = c_ulong;
pub type __dev_t = c_ulong;
pub type __uid_t = c_uint;
pub type __gid_t = c_uint;
pub type __ino_t = c_ulong;
pub type __ino64_t = c_ulong;
pub type __mode_t = c_uint;
pub type __nlink_t = c_ulong;
pub type __off_t = c_long;
pub type __off64_t = c_long;
pub type __pid_t = c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = c_long;
pub type __rlim_t = c_ulong;
pub type __rlim64_t = c_ulong;
pub type __id_t = c_uint;
pub type __time_t = c_long;
pub type __useconds_t = c_uint;
pub type __suseconds_t = c_long;
pub type __daddr_t = c_int;
pub type __key_t = c_int;
pub type __clockid_t = c_int;
pub type __timer_t = *mut c_void;
pub type __blksize_t = c_long;
pub type __blkcnt_t = c_long;
pub type __blkcnt64_t = c_long;
pub type __fsblkcnt_t = c_ulong;
pub type __fsblkcnt64_t = c_ulong;
pub type __fsfilcnt_t = c_ulong;
pub type __fsfilcnt64_t = c_ulong;
pub type __fsword_t = c_long;
pub type __ssize_t = c_long;
pub type __syscall_slong_t = c_long;
pub type __syscall_ulong_t = c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut c_char;
pub type __intptr_t = c_long;
pub type __socklen_t = c_uint;
pub type __sig_atomic_t = c_int;
pub type int_least8_t = c_schar;
pub type int_least16_t = c_short;
pub type int_least32_t = c_int;
pub type int_least64_t = c_long;
pub type uint_least8_t = c_uchar;
pub type uint_least16_t = c_ushort;
pub type uint_least32_t = c_uint;
pub type uint_least64_t = c_ulong;
pub type int_fast8_t = c_schar;
pub type int_fast16_t = c_long;
pub type int_fast32_t = c_long;
pub type int_fast64_t = c_long;
pub type uint_fast8_t = c_uchar;
pub type uint_fast16_t = c_ulong;
pub type uint_fast32_t = c_ulong;
pub type uint_fast64_t = c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type wchar_t = c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[repr(u32)]
/// implementation specific types
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum kmp_mutex_impl_t {
    kmp_mutex_impl_none = 0,
    kmp_mutex_impl_spin = 1,
    kmp_mutex_impl_queuing = 2,
    kmp_mutex_impl_speculative = 3,
}
#[repr(u32)]
/// definitions generated from spec
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Callbacks {
    ThreadBegin = 1,
    ThreadEnd = 2,
    ParallelBegin = 3,
    ParallelEnd = 4,
    TaskCreate = 5,
    TaskSchedule = 6,
    ImplicitTask = 7,
    Target = 8,
    TargetDataOp = 9,
    TargetSubmit = 10,
    ControlTool = 11,
    DeviceInitialize = 12,
    DeviceFinalize = 13,
    DeviceLoad = 14,
    DeviceUnload = 15,
    SyncRegionWait = 16,
    MutexReleased = 17,
    Dependences = 18,
    TaskDependence = 19,
    Work = 20,
    Master = 21,
    TargetMap = 22,
    SyncRegion = 23,
    LockInit = 24,
    LockDestroy = 25,
    MutexAcquire = 26,
    MutexAcquired = 27,
    NestLock = 28,
    Flush = 29,
    Cancel = 30,
    Reduction = 31,
    Dispatch = 32,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Record {
    RecordOmpt = 1,
    RecordNative = 2,
    RecordInvalid = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RecordNative {
    RecordNativeInfo = 1,
    RecordNativeEvent = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SetResult {
    Error = 0,
    Never = 1,
    Impossible = 2,
    Sometimes = 3,
    SometimesPaired = 4,
    Always = 5,
}
pub type Id = u64;
pub type DeviceTime = u64;
pub type BufferCursor = u64;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Thread {
    ThreadInitial = 1,
    ThreadWorker = 2,
    ThreadOther = 3,
    ThreadUnknown = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Endpoint {
    Begin = 1,
    End = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Dispatch {
    DispatchIteration = 1,
    DispatchSection = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SyncRegion {
    Barrier = 1,
    BarrierImplicit = 2,
    BarrierExplicit = 3,
    BarrierImplementation = 4,
    Taskwait = 5,
    Taskgroup = 6,
    Reduction = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum TargetDataOp {
    TargetDataAlloc = 1,
    TargetDataTransferToDevice = 2,
    TargetDataTransferFromDevice = 3,
    TargetDataDelete = 4,
    TargetDataAssociate = 5,
    TargetDataDisassociate = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Work {
    Loop = 1,
    Sections = 2,
    SingleExecutor = 3,
    SingleOther = 4,
    Workshare = 5,
    Distribute = 6,
    Taskloop = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Mutex {
    Lock = 1,
    TestLock = 2,
    NestLock = 3,
    TestNestLock = 4,
    Critical = 5,
    Atomic = 6,
    Ordered = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum NativeMonFlag {
    NativeDataMotionExplicit = 1,
    NativeDataMotionImplicit = 2,
    NativeKernelInvocation = 4,
    NativeKernelExecution = 8,
    NativeDriver = 16,
    NativeRuntime = 32,
    NativeOverhead = 64,
    NativeIdleness = 128,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum TaskFlag {
    Initial = 1,
    Implicit = 2,
    Explicit = 4,
    Target = 8,
    Undeferred = 134217728,
    Untied = 268435456,
    Final = 536870912,
    Mergeable = 1073741824,
    Merged = 2147483648,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum TaskStatus {
    Complete = 1,
    Yield = 2,
    Cancel = 3,
    Detach = 4,
    EarlyFulfill = 5,
    LateFulfill = 6,
    Switch = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Target {
    Target = 1,
    TargetEnterData = 2,
    TargetExitData = 3,
    TargetUpdate = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ParallelFlag {
    ParallelInvokerProgram = 1,
    ParallelInvokerRuntime = 2,
    ParallelLeague = 1073741824,
    ParallelTeam = 2147483648,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum TargetMapFlag {
    TargetMapFlagTo = 1,
    TargetMapFlagFrom = 2,
    TargetMapFlagAlloc = 4,
    TargetMapFlagRelease = 8,
    TargetMapFlagDelete = 16,
    TargetMapFlagImplicit = 32,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DependenceType {
    DependenceTypeIn = 1,
    DependenceTypeOut = 2,
    DependenceTypeInout = 3,
    DependenceTypeMutexinoutset = 4,
    DependenceTypeSource = 5,
    DependenceTypeSink = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CancelFlag {
    Parallel = 1,
    Sections = 2,
    Loop = 4,
    Taskgroup = 8,
    Activated = 16,
    Detected = 32,
    DiscardedTask = 64,
}
pub type Hwid = u64;
pub type WaitId = u64;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FrameFlag {
    FrameRuntime = 0,
    FrameApplication = 1,
    FrameCfa = 16,
    FrameFramepointer = 32,
    FrameStackaddress = 48,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum State {
    StateWorkSerial = 0,
    StateWorkParallel = 1,
    StateWorkReduction = 2,
    StateWaitBarrier = 16,
    StateWaitBarrierImplicitParallel = 17,
    StateWaitBarrierImplicitWorkshare = 18,
    StateWaitBarrierImplicit = 19,
    StateWaitBarrierExplicit = 20,
    StateWaitTaskwait = 32,
    StateWaitTaskgroup = 33,
    StateWaitMutex = 64,
    StateWaitLock = 65,
    StateWaitCritical = 66,
    StateWaitAtomic = 67,
    StateWaitOrdered = 68,
    StateWaitTarget = 128,
    StateWaitTargetMap = 129,
    StateWaitTargetUpdate = 130,
    StateIdle = 256,
    StateOverhead = 257,
    StateUndefined = 258,
}
pub type GetUniqueId = Option<unsafe extern "C" fn() -> u64>;
pub type ompd_size_t = u64;
pub type ompd_wait_id_t = u64;
pub type ompd_addr_t = u64;
pub type ompd_word_t = i64;
pub type ompd_seg_t = u64;
pub type ompd_device_t = u64;
pub type ompd_thread_id_t = u64;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ompd_scope_t {
    ompd_scope_global = 1,
    ompd_scope_address_space = 2,
    ompd_scope_thread = 3,
    ompd_scope_parallel = 4,
    ompd_scope_implicit_task = 5,
    ompd_scope_task = 6,
}
pub type ompd_icv_id_t = u64;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ompd_rc_t {
    ompd_rc_ok = 0,
    ompd_rc_unavailable = 1,
    ompd_rc_stale_handle = 2,
    ompd_rc_bad_input = 3,
    ompd_rc_error = 4,
    ompd_rc_unsupported = 5,
    ompd_rc_needs_state_tracking = 6,
    ompd_rc_incompatible = 7,
    ompd_rc_device_read_error = 8,
    ompd_rc_device_write_error = 9,
    ompd_rc_nomem = 10,
}
pub type InterfaceFnFn = Option<unsafe extern "C" fn()>;
pub type FunctionLookupFn = Option<
    unsafe extern "C" fn(
        interface_function_name: *const c_char,
    ) -> InterfaceFnFn,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub union Data {
    pub value: u64,
    pub ptr: *mut c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_Data() {
    assert_eq!(
        ::std::mem::size_of::<Data>(),
        8usize,
        concat!("Size of: ", stringify!(Data))
    );
    assert_eq!(
        ::std::mem::align_of::<Data>(),
        8usize,
        concat!("Alignment of ", stringify!(Data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Data>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Data),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Data>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Data),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Frame {
    pub exit_frame: Data,
    pub enter_frame: Data,
    pub exit_frame_flags: c_int,
    pub enter_frame_flags: c_int,
}
#[test]
fn bindgen_test_layout_Frame() {
    assert_eq!(
        ::std::mem::size_of::<Frame>(),
        24usize,
        concat!("Size of: ", stringify!(Frame))
    );
    assert_eq!(
        ::std::mem::align_of::<Frame>(),
        8usize,
        concat!("Alignment of ", stringify!(Frame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Frame>())).exit_frame as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Frame),
            "::",
            stringify!(exit_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Frame>())).enter_frame as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Frame),
            "::",
            stringify!(enter_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Frame>())).exit_frame_flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Frame),
            "::",
            stringify!(exit_frame_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Frame>())).enter_frame_flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Frame),
            "::",
            stringify!(enter_frame_flags)
        )
    );
}
pub type CallbackFn = Option<unsafe extern "C" fn()>;
pub type Device = c_void;
pub type Buffer = c_void;
pub type CallbackBufferRequestFn = Option<
    unsafe extern "C" fn(
        device_num: c_int,
        buffer: *mut *mut Buffer,
        bytes: *mut usize,
    ),
>;
pub type CallbackBufferCompleteFn = Option<
    unsafe extern "C" fn(
        device_num: c_int,
        buffer: *mut Buffer,
        bytes: usize,
        begin: BufferCursor,
        buffer_owned: c_int,
    ),
>;
pub type FinalizeFn = Option<unsafe extern "C" fn(tool_data: *mut Data)>;
pub type InitializeFn = Option<
    unsafe extern "C" fn(
        lookup: FunctionLookupFn,
        initial_device_num: c_int,
        tool_data: *mut Data,
    ) -> c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct StartToolResult {
    pub initialize: InitializeFn,
    pub finalize: FinalizeFn,
    pub tool_data: Data,
}
#[test]
fn bindgen_test_layout_StartToolResult() {
    assert_eq!(
        ::std::mem::size_of::<StartToolResult>(),
        24usize,
        concat!("Size of: ", stringify!(StartToolResult))
    );
    assert_eq!(
        ::std::mem::align_of::<StartToolResult>(),
        8usize,
        concat!("Alignment of ", stringify!(StartToolResult))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<StartToolResult>())).initialize as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(StartToolResult),
            "::",
            stringify!(initialize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<StartToolResult>())).finalize as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(StartToolResult),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<StartToolResult>())).tool_data as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(StartToolResult),
            "::",
            stringify!(tool_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecordAbstract {
    pub rclass: RecordNative,
    pub type_: *const c_char,
    pub start_time: DeviceTime,
    pub end_time: DeviceTime,
    pub hwid: Hwid,
}
#[test]
fn bindgen_test_layout_RecordAbstract() {
    assert_eq!(
        ::std::mem::size_of::<RecordAbstract>(),
        40usize,
        concat!("Size of: ", stringify!(RecordAbstract))
    );
    assert_eq!(
        ::std::mem::align_of::<RecordAbstract>(),
        8usize,
        concat!("Alignment of ", stringify!(RecordAbstract))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordAbstract>())).rclass as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordAbstract),
            "::",
            stringify!(rclass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordAbstract>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordAbstract),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordAbstract>())).start_time as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordAbstract),
            "::",
            stringify!(start_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordAbstract>())).end_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordAbstract),
            "::",
            stringify!(end_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordAbstract>())).hwid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordAbstract),
            "::",
            stringify!(hwid)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Dependence {
    pub variable: Data,
    pub dependence_type: DependenceType,
}
#[test]
fn bindgen_test_layout_Dependence() {
    assert_eq!(
        ::std::mem::size_of::<Dependence>(),
        16usize,
        concat!("Size of: ", stringify!(Dependence))
    );
    assert_eq!(
        ::std::mem::align_of::<Dependence>(),
        8usize,
        concat!("Alignment of ", stringify!(Dependence))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Dependence>())).variable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dependence),
            "::",
            stringify!(variable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Dependence>())).dependence_type as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Dependence),
            "::",
            stringify!(dependence_type)
        )
    );
}
pub type EnumerateStates = Option<
    unsafe extern "C" fn(
        current_state: c_int,
        next_state: *mut c_int,
        next_state_name: *mut *const c_char,
    ) -> c_int,
>;
pub type EnumerateMutexImpls = Option<
    unsafe extern "C" fn(
        current_impl: c_int,
        next_impl: *mut c_int,
        next_impl_name: *mut *const c_char,
    ) -> c_int,
>;
pub type SetCallbackFn = Option<
    unsafe extern "C" fn(event: Callbacks, callback: CallbackFn) -> SetResult,
>;
pub type GetCallbackFn = Option<
    unsafe extern "C" fn(
        event: Callbacks,
        callback: *mut CallbackFn,
    ) -> c_int,
>;
pub type GetThreadData = Option<unsafe extern "C" fn() -> *mut Data>;
pub type GetNumProcs =
    Option<unsafe extern "C" fn() -> c_int>;
pub type GetNumPlaces =
    Option<unsafe extern "C" fn() -> c_int>;
pub type GetPlaceProcIds = Option<
    unsafe extern "C" fn(
        place_num: c_int,
        ids_size: c_int,
        ids: *mut c_int,
    ) -> c_int,
>;
pub type GetPlaceNum =
    Option<unsafe extern "C" fn() -> c_int>;
pub type GetPartitionPlaceNums = Option<
    unsafe extern "C" fn(
        place_nums_size: c_int,
        place_nums: *mut c_int,
    ) -> c_int,
>;
pub type GetProcId =
    Option<unsafe extern "C" fn() -> c_int>;
pub type GetState = Option<
    unsafe extern "C" fn(wait_id: *mut WaitId) -> c_int,
>;
pub type GetParallelInfo = Option<
    unsafe extern "C" fn(
        ancestor_level: c_int,
        parallel_data: *mut *mut Data,
        team_size: *mut c_int,
    ) -> c_int,
>;
pub type GetTaskInfo = Option<
    unsafe extern "C" fn(
        ancestor_level: c_int,
        flags: *mut c_int,
        task_data: *mut *mut Data,
        task_frame: *mut *mut Frame,
        parallel_data: *mut *mut Data,
        thread_num: *mut c_int,
    ) -> c_int,
>;
pub type GetTaskMemory = Option<
    unsafe extern "C" fn(
        addr: *mut *mut c_void,
        size: *mut usize,
        block: c_int,
    ) -> c_int,
>;
pub type GetTargetInfo = Option<
    unsafe extern "C" fn(
        device_num: *mut u64,
        target_id: *mut Id,
        host_op_id: *mut Id,
    ) -> c_int,
>;
pub type GetNumDevices =
    Option<unsafe extern "C" fn() -> c_int>;
pub type FinalizeToolFn = Option<unsafe extern "C" fn()>;
pub type GetDeviceNumProcs = Option<
    unsafe extern "C" fn(device: *mut Device) -> c_int,
>;
pub type GetDeviceTime =
    Option<unsafe extern "C" fn(device: *mut Device) -> DeviceTime>;
pub type TranslateTime = Option<
    unsafe extern "C" fn(device: *mut Device, time: DeviceTime) -> f64,
>;
pub type SetTraceOmpt = Option<
    unsafe extern "C" fn(
        device: *mut Device,
        enable: c_uint,
        etype: c_uint,
    ) -> SetResult,
>;
pub type SetTraceNative = Option<
    unsafe extern "C" fn(
        device: *mut Device,
        enable: c_int,
        flags: c_int,
    ) -> SetResult,
>;
pub type StartTrace = Option<
    unsafe extern "C" fn(
        device: *mut Device,
        request: CallbackBufferRequestFn,
        complete: CallbackBufferCompleteFn,
    ) -> c_int,
>;
pub type PauseTrace = Option<
    unsafe extern "C" fn(
        device: *mut Device,
        begin_pause: c_int,
    ) -> c_int,
>;
pub type FlushTrace = Option<
    unsafe extern "C" fn(device: *mut Device) -> c_int,
>;
pub type StopTrace = Option<
    unsafe extern "C" fn(device: *mut Device) -> c_int,
>;
pub type AdvanceBufferCursor = Option<
    unsafe extern "C" fn(
        device: *mut Device,
        buffer: *mut Buffer,
        size: usize,
        current: BufferCursor,
        next: *mut BufferCursor,
    ) -> c_int,
>;
pub type GetRecordType = Option<
    unsafe extern "C" fn(
        buffer: *mut Buffer,
        current: BufferCursor,
    ) -> Record,
>;
pub type GetRecordNative = Option<
    unsafe extern "C" fn(
        buffer: *mut Buffer,
        current: BufferCursor,
        host_op_id: *mut Id,
    ) -> *mut c_void,
>;
pub type GetRecordAbstract = Option<
    unsafe extern "C" fn(native_record: *mut c_void) -> *mut RecordAbstract,
>;
pub type CallbackThreadBeginFn = Option<
    unsafe extern "C" fn(thread_type: Thread, thread_data: *mut Data),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecordThreadBegin {
    pub thread_type: Thread,
}
#[test]
fn bindgen_test_layout_RecordThreadBegin() {
    assert_eq!(
        ::std::mem::size_of::<RecordThreadBegin>(),
        4usize,
        concat!("Size of: ", stringify!(RecordThreadBegin))
    );
    assert_eq!(
        ::std::mem::align_of::<RecordThreadBegin>(),
        4usize,
        concat!("Alignment of ", stringify!(RecordThreadBegin))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordThreadBegin>())).thread_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordThreadBegin),
            "::",
            stringify!(thread_type)
        )
    );
}
pub type CallbackThreadEndFn =
    Option<unsafe extern "C" fn(thread_data: *mut Data)>;
pub type CallbackParallelBeginFn = Option<
    unsafe extern "C" fn(
        encountering_task_data: *mut Data,
        encountering_task_frame: *const Frame,
        parallel_data: *mut Data,
        requested_parallelism: c_uint,
        flags: c_int,
        codeptr_ra: *const c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecordParallelBegin {
    pub encountering_task_id: Id,
    pub parallel_id: Id,
    pub requested_parallelism: c_uint,
    pub flags: c_int,
    pub codeptr_ra: *const c_void,
}
#[test]
fn bindgen_test_layout_RecordParallelBegin() {
    assert_eq!(
        ::std::mem::size_of::<RecordParallelBegin>(),
        32usize,
        concat!("Size of: ", stringify!(RecordParallelBegin))
    );
    assert_eq!(
        ::std::mem::align_of::<RecordParallelBegin>(),
        8usize,
        concat!("Alignment of ", stringify!(RecordParallelBegin))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordParallelBegin>())).encountering_task_id
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordParallelBegin),
            "::",
            stringify!(encountering_task_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordParallelBegin>())).parallel_id as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordParallelBegin),
            "::",
            stringify!(parallel_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordParallelBegin>())).requested_parallelism
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordParallelBegin),
            "::",
            stringify!(requested_parallelism)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordParallelBegin>())).flags as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordParallelBegin),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordParallelBegin>())).codeptr_ra as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordParallelBegin),
            "::",
            stringify!(codeptr_ra)
        )
    );
}
pub type CallbackParallelEndFn = Option<
    unsafe extern "C" fn(
        parallel_data: *mut Data,
        encountering_task_data: *mut Data,
        flags: c_int,
        codeptr_ra: *const c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecordParallelEnd {
    pub parallel_id: Id,
    pub encountering_task_id: Id,
    pub flags: c_int,
    pub codeptr_ra: *const c_void,
}
#[test]
fn bindgen_test_layout_RecordParallelEnd() {
    assert_eq!(
        ::std::mem::size_of::<RecordParallelEnd>(),
        32usize,
        concat!("Size of: ", stringify!(RecordParallelEnd))
    );
    assert_eq!(
        ::std::mem::align_of::<RecordParallelEnd>(),
        8usize,
        concat!("Alignment of ", stringify!(RecordParallelEnd))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordParallelEnd>())).parallel_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordParallelEnd),
            "::",
            stringify!(parallel_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordParallelEnd>())).encountering_task_id as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordParallelEnd),
            "::",
            stringify!(encountering_task_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordParallelEnd>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordParallelEnd),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordParallelEnd>())).codeptr_ra as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordParallelEnd),
            "::",
            stringify!(codeptr_ra)
        )
    );
}
pub type CallbackWorkFn = Option<
    unsafe extern "C" fn(
        wstype: Work,
        endpoint: Endpoint,
        parallel_data: *mut Data,
        task_data: *mut Data,
        count: u64,
        codeptr_ra: *const c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecordWork {
    pub wstype: Work,
    pub endpoint: Endpoint,
    pub parallel_id: Id,
    pub task_id: Id,
    pub count: u64,
    pub codeptr_ra: *const c_void,
}
#[test]
fn bindgen_test_layout_RecordWork() {
    assert_eq!(
        ::std::mem::size_of::<RecordWork>(),
        40usize,
        concat!("Size of: ", stringify!(RecordWork))
    );
    assert_eq!(
        ::std::mem::align_of::<RecordWork>(),
        8usize,
        concat!("Alignment of ", stringify!(RecordWork))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordWork>())).wstype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordWork),
            "::",
            stringify!(wstype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordWork>())).endpoint as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordWork),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordWork>())).parallel_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordWork),
            "::",
            stringify!(parallel_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordWork>())).task_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordWork),
            "::",
            stringify!(task_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordWork>())).count as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordWork),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordWork>())).codeptr_ra as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordWork),
            "::",
            stringify!(codeptr_ra)
        )
    );
}
pub type CallbackDispatchFn = Option<
    unsafe extern "C" fn(
        parallel_data: *mut Data,
        task_data: *mut Data,
        kind: Dispatch,
        instance: Data,
    ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RecordDispatch {
    pub parallel_id: Id,
    pub task_id: Id,
    pub kind: Dispatch,
    pub instance: Data,
}
#[test]
fn bindgen_test_layout_RecordDispatch() {
    assert_eq!(
        ::std::mem::size_of::<RecordDispatch>(),
        32usize,
        concat!("Size of: ", stringify!(RecordDispatch))
    );
    assert_eq!(
        ::std::mem::align_of::<RecordDispatch>(),
        8usize,
        concat!("Alignment of ", stringify!(RecordDispatch))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordDispatch>())).parallel_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordDispatch),
            "::",
            stringify!(parallel_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordDispatch>())).task_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordDispatch),
            "::",
            stringify!(task_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordDispatch>())).kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordDispatch),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordDispatch>())).instance as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordDispatch),
            "::",
            stringify!(instance)
        )
    );
}
pub type CallbackTaskCreateFn = Option<
    unsafe extern "C" fn(
        encountering_task_data: *mut Data,
        encountering_task_frame: *const Frame,
        new_task_data: *mut Data,
        flags: c_int,
        has_dependences: c_int,
        codeptr_ra: *const c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecordTaskCreate {
    pub encountering_task_id: Id,
    pub new_task_id: Id,
    pub flags: c_int,
    pub has_dependences: c_int,
    pub codeptr_ra: *const c_void,
}
#[test]
fn bindgen_test_layout_RecordTaskCreate() {
    assert_eq!(
        ::std::mem::size_of::<RecordTaskCreate>(),
        32usize,
        concat!("Size of: ", stringify!(RecordTaskCreate))
    );
    assert_eq!(
        ::std::mem::align_of::<RecordTaskCreate>(),
        8usize,
        concat!("Alignment of ", stringify!(RecordTaskCreate))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordTaskCreate>())).encountering_task_id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTaskCreate),
            "::",
            stringify!(encountering_task_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordTaskCreate>())).new_task_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTaskCreate),
            "::",
            stringify!(new_task_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordTaskCreate>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTaskCreate),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordTaskCreate>())).has_dependences as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTaskCreate),
            "::",
            stringify!(has_dependences)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordTaskCreate>())).codeptr_ra as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTaskCreate),
            "::",
            stringify!(codeptr_ra)
        )
    );
}
pub type CallbackDependencesFn = Option<
    unsafe extern "C" fn(
        task_data: *mut Data,
        deps: *const Dependence,
        ndeps: c_int,
    ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RecordDependences {
    pub task_id: Id,
    pub dep: Dependence,
    pub ndeps: c_int,
}
#[test]
fn bindgen_test_layout_RecordDependences() {
    assert_eq!(
        ::std::mem::size_of::<RecordDependences>(),
        32usize,
        concat!("Size of: ", stringify!(RecordDependences))
    );
    assert_eq!(
        ::std::mem::align_of::<RecordDependences>(),
        8usize,
        concat!("Alignment of ", stringify!(RecordDependences))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordDependences>())).task_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordDependences),
            "::",
            stringify!(task_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordDependences>())).dep as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordDependences),
            "::",
            stringify!(dep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordDependences>())).ndeps as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordDependences),
            "::",
            stringify!(ndeps)
        )
    );
}
pub type CallbackTaskDependenceFn = Option<
    unsafe extern "C" fn(src_task_data: *mut Data, sink_task_data: *mut Data),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecordTaskDependence {
    pub src_task_id: Id,
    pub sink_task_id: Id,
}
#[test]
fn bindgen_test_layout_RecordTaskDependence() {
    assert_eq!(
        ::std::mem::size_of::<RecordTaskDependence>(),
        16usize,
        concat!("Size of: ", stringify!(RecordTaskDependence))
    );
    assert_eq!(
        ::std::mem::align_of::<RecordTaskDependence>(),
        8usize,
        concat!("Alignment of ", stringify!(RecordTaskDependence))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordTaskDependence>())).src_task_id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTaskDependence),
            "::",
            stringify!(src_task_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordTaskDependence>())).sink_task_id as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTaskDependence),
            "::",
            stringify!(sink_task_id)
        )
    );
}
pub type CallbackTaskScheduleFn = Option<
    unsafe extern "C" fn(
        prior_task_data: *mut Data,
        prior_task_status: TaskStatus,
        next_task_data: *mut Data,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecordTaskSchedule {
    pub prior_task_id: Id,
    pub prior_task_status: TaskStatus,
    pub next_task_id: Id,
}
#[test]
fn bindgen_test_layout_RecordTaskSchedule() {
    assert_eq!(
        ::std::mem::size_of::<RecordTaskSchedule>(),
        24usize,
        concat!("Size of: ", stringify!(RecordTaskSchedule))
    );
    assert_eq!(
        ::std::mem::align_of::<RecordTaskSchedule>(),
        8usize,
        concat!("Alignment of ", stringify!(RecordTaskSchedule))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordTaskSchedule>())).prior_task_id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTaskSchedule),
            "::",
            stringify!(prior_task_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordTaskSchedule>())).prior_task_status as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTaskSchedule),
            "::",
            stringify!(prior_task_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordTaskSchedule>())).next_task_id as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTaskSchedule),
            "::",
            stringify!(next_task_id)
        )
    );
}
pub type CallbackImplicitTaskFn = Option<
    unsafe extern "C" fn(
        endpoint: Endpoint,
        parallel_data: *mut Data,
        task_data: *mut Data,
        actual_parallelism: c_uint,
        index: c_uint,
        flags: c_int,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecordImplicitTask {
    pub endpoint: Endpoint,
    pub parallel_id: Id,
    pub task_id: Id,
    pub actual_parallelism: c_uint,
    pub index: c_uint,
    pub flags: c_int,
}
#[test]
fn bindgen_test_layout_RecordImplicitTask() {
    assert_eq!(
        ::std::mem::size_of::<RecordImplicitTask>(),
        40usize,
        concat!("Size of: ", stringify!(RecordImplicitTask))
    );
    assert_eq!(
        ::std::mem::align_of::<RecordImplicitTask>(),
        8usize,
        concat!("Alignment of ", stringify!(RecordImplicitTask))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordImplicitTask>())).endpoint as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordImplicitTask),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordImplicitTask>())).parallel_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordImplicitTask),
            "::",
            stringify!(parallel_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordImplicitTask>())).task_id as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordImplicitTask),
            "::",
            stringify!(task_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordImplicitTask>())).actual_parallelism as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordImplicitTask),
            "::",
            stringify!(actual_parallelism)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordImplicitTask>())).index as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordImplicitTask),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordImplicitTask>())).flags as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordImplicitTask),
            "::",
            stringify!(flags)
        )
    );
}
pub type CallbackMasterFn = Option<
    unsafe extern "C" fn(
        endpoint: Endpoint,
        parallel_data: *mut Data,
        task_data: *mut Data,
        codeptr_ra: *const c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecordMaster {
    pub endpoint: Endpoint,
    pub parallel_id: Id,
    pub task_id: Id,
    pub codeptr_ra: *const c_void,
}
#[test]
fn bindgen_test_layout_RecordMaster() {
    assert_eq!(
        ::std::mem::size_of::<RecordMaster>(),
        32usize,
        concat!("Size of: ", stringify!(RecordMaster))
    );
    assert_eq!(
        ::std::mem::align_of::<RecordMaster>(),
        8usize,
        concat!("Alignment of ", stringify!(RecordMaster))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordMaster>())).endpoint as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordMaster),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordMaster>())).parallel_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordMaster),
            "::",
            stringify!(parallel_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordMaster>())).task_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordMaster),
            "::",
            stringify!(task_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordMaster>())).codeptr_ra as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordMaster),
            "::",
            stringify!(codeptr_ra)
        )
    );
}
pub type CallbackSyncRegionFn = Option<
    unsafe extern "C" fn(
        kind: SyncRegion,
        endpoint: Endpoint,
        parallel_data: *mut Data,
        task_data: *mut Data,
        codeptr_ra: *const c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecordSyncRegion {
    pub kind: SyncRegion,
    pub endpoint: Endpoint,
    pub parallel_id: Id,
    pub task_id: Id,
    pub codeptr_ra: *const c_void,
}
#[test]
fn bindgen_test_layout_RecordSyncRegion() {
    assert_eq!(
        ::std::mem::size_of::<RecordSyncRegion>(),
        32usize,
        concat!("Size of: ", stringify!(RecordSyncRegion))
    );
    assert_eq!(
        ::std::mem::align_of::<RecordSyncRegion>(),
        8usize,
        concat!("Alignment of ", stringify!(RecordSyncRegion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordSyncRegion>())).kind as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordSyncRegion),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordSyncRegion>())).endpoint as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordSyncRegion),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordSyncRegion>())).parallel_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordSyncRegion),
            "::",
            stringify!(parallel_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordSyncRegion>())).task_id as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordSyncRegion),
            "::",
            stringify!(task_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordSyncRegion>())).codeptr_ra as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordSyncRegion),
            "::",
            stringify!(codeptr_ra)
        )
    );
}
pub type CallbackMutexAcquireFn = Option<
    unsafe extern "C" fn(
        kind: Mutex,
        hint: c_uint,
        impl_: c_uint,
        wait_id: WaitId,
        codeptr_ra: *const c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecordMutexAcquire {
    pub kind: Mutex,
    pub hint: c_uint,
    pub impl_: c_uint,
    pub wait_id: WaitId,
    pub codeptr_ra: *const c_void,
}
#[test]
fn bindgen_test_layout_RecordMutexAcquire() {
    assert_eq!(
        ::std::mem::size_of::<RecordMutexAcquire>(),
        32usize,
        concat!("Size of: ", stringify!(RecordMutexAcquire))
    );
    assert_eq!(
        ::std::mem::align_of::<RecordMutexAcquire>(),
        8usize,
        concat!("Alignment of ", stringify!(RecordMutexAcquire))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordMutexAcquire>())).kind as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordMutexAcquire),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordMutexAcquire>())).hint as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordMutexAcquire),
            "::",
            stringify!(hint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordMutexAcquire>())).impl_ as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordMutexAcquire),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordMutexAcquire>())).wait_id as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordMutexAcquire),
            "::",
            stringify!(wait_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordMutexAcquire>())).codeptr_ra as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordMutexAcquire),
            "::",
            stringify!(codeptr_ra)
        )
    );
}
pub type CallbackMutexFn = Option<
    unsafe extern "C" fn(
        kind: Mutex,
        wait_id: WaitId,
        codeptr_ra: *const c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecordMutex {
    pub kind: Mutex,
    pub wait_id: WaitId,
    pub codeptr_ra: *const c_void,
}
#[test]
fn bindgen_test_layout_RecordMutex() {
    assert_eq!(
        ::std::mem::size_of::<RecordMutex>(),
        24usize,
        concat!("Size of: ", stringify!(RecordMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<RecordMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(RecordMutex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordMutex>())).kind as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordMutex),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordMutex>())).wait_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordMutex),
            "::",
            stringify!(wait_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordMutex>())).codeptr_ra as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordMutex),
            "::",
            stringify!(codeptr_ra)
        )
    );
}
pub type CallbackNestLockFn = Option<
    unsafe extern "C" fn(
        endpoint: Endpoint,
        wait_id: WaitId,
        codeptr_ra: *const c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecordNestLock {
    pub endpoint: Endpoint,
    pub wait_id: WaitId,
    pub codeptr_ra: *const c_void,
}
#[test]
fn bindgen_test_layout_RecordNestLock() {
    assert_eq!(
        ::std::mem::size_of::<RecordNestLock>(),
        24usize,
        concat!("Size of: ", stringify!(RecordNestLock))
    );
    assert_eq!(
        ::std::mem::align_of::<RecordNestLock>(),
        8usize,
        concat!("Alignment of ", stringify!(RecordNestLock))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordNestLock>())).endpoint as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordNestLock),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordNestLock>())).wait_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordNestLock),
            "::",
            stringify!(wait_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordNestLock>())).codeptr_ra as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordNestLock),
            "::",
            stringify!(codeptr_ra)
        )
    );
}
pub type CallbackFlushFn = Option<
    unsafe extern "C" fn(thread_data: *mut Data, codeptr_ra: *const c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecordFlush {
    pub codeptr_ra: *const c_void,
}
#[test]
fn bindgen_test_layout_RecordFlush() {
    assert_eq!(
        ::std::mem::size_of::<RecordFlush>(),
        8usize,
        concat!("Size of: ", stringify!(RecordFlush))
    );
    assert_eq!(
        ::std::mem::align_of::<RecordFlush>(),
        8usize,
        concat!("Alignment of ", stringify!(RecordFlush))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordFlush>())).codeptr_ra as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordFlush),
            "::",
            stringify!(codeptr_ra)
        )
    );
}
pub type CallbackCancelFn = Option<
    unsafe extern "C" fn(
        task_data: *mut Data,
        flags: c_int,
        codeptr_ra: *const c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecordCancel {
    pub task_id: Id,
    pub flags: c_int,
    pub codeptr_ra: *const c_void,
}
#[test]
fn bindgen_test_layout_RecordCancel() {
    assert_eq!(
        ::std::mem::size_of::<RecordCancel>(),
        24usize,
        concat!("Size of: ", stringify!(RecordCancel))
    );
    assert_eq!(
        ::std::mem::align_of::<RecordCancel>(),
        8usize,
        concat!("Alignment of ", stringify!(RecordCancel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordCancel>())).task_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordCancel),
            "::",
            stringify!(task_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordCancel>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordCancel),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordCancel>())).codeptr_ra as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordCancel),
            "::",
            stringify!(codeptr_ra)
        )
    );
}
pub type CallbackDeviceInitializeFn = Option<
    unsafe extern "C" fn(
        device_num: c_int,
        type_: *const c_char,
        device: *mut Device,
        lookup: FunctionLookupFn,
        documentation: *const c_char,
    ),
>;
pub type CallbackDeviceFinalizeFn =
    Option<unsafe extern "C" fn(device_num: c_int)>;
pub type CallbackDeviceLoadFn = Option<
    unsafe extern "C" fn(
        device_num: c_int,
        filename: *const c_char,
        offset_in_file: i64,
        vma_in_file: *mut c_void,
        bytes: usize,
        host_addr: *mut c_void,
        device_addr: *mut c_void,
        module_id: u64,
    ),
>;
pub type CallbackDeviceUnloadFn =
    Option<unsafe extern "C" fn(device_num: c_int, module_id: u64)>;
pub type CallbackTargetDataOpFn = Option<
    unsafe extern "C" fn(
        target_id: Id,
        host_op_id: Id,
        optype: TargetDataOp,
        src_addr: *mut c_void,
        src_device_num: c_int,
        dest_addr: *mut c_void,
        dest_device_num: c_int,
        bytes: usize,
        codeptr_ra: *const c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecordTargetDataOp {
    pub host_op_id: Id,
    pub optype: TargetDataOp,
    pub src_addr: *mut c_void,
    pub src_device_num: c_int,
    pub dest_addr: *mut c_void,
    pub dest_device_num: c_int,
    pub bytes: usize,
    pub end_time: DeviceTime,
    pub codeptr_ra: *const c_void,
}
#[test]
fn bindgen_test_layout_RecordTargetDataOp() {
    assert_eq!(
        ::std::mem::size_of::<RecordTargetDataOp>(),
        72usize,
        concat!("Size of: ", stringify!(RecordTargetDataOp))
    );
    assert_eq!(
        ::std::mem::align_of::<RecordTargetDataOp>(),
        8usize,
        concat!("Alignment of ", stringify!(RecordTargetDataOp))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordTargetDataOp>())).host_op_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTargetDataOp),
            "::",
            stringify!(host_op_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordTargetDataOp>())).optype as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTargetDataOp),
            "::",
            stringify!(optype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordTargetDataOp>())).src_addr as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTargetDataOp),
            "::",
            stringify!(src_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordTargetDataOp>())).src_device_num as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTargetDataOp),
            "::",
            stringify!(src_device_num)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordTargetDataOp>())).dest_addr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTargetDataOp),
            "::",
            stringify!(dest_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordTargetDataOp>())).dest_device_num as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTargetDataOp),
            "::",
            stringify!(dest_device_num)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordTargetDataOp>())).bytes as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTargetDataOp),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordTargetDataOp>())).end_time as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTargetDataOp),
            "::",
            stringify!(end_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordTargetDataOp>())).codeptr_ra as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTargetDataOp),
            "::",
            stringify!(codeptr_ra)
        )
    );
}
pub type CallbackTargetFn = Option<
    unsafe extern "C" fn(
        kind: Target,
        endpoint: Endpoint,
        device_num: c_int,
        task_data: *mut Data,
        target_id: Id,
        codeptr_ra: *const c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecordTarget {
    pub kind: Target,
    pub endpoint: Endpoint,
    pub device_num: c_int,
    pub task_id: Id,
    pub target_id: Id,
    pub codeptr_ra: *const c_void,
}
#[test]
fn bindgen_test_layout_RecordTarget() {
    assert_eq!(
        ::std::mem::size_of::<RecordTarget>(),
        40usize,
        concat!("Size of: ", stringify!(RecordTarget))
    );
    assert_eq!(
        ::std::mem::align_of::<RecordTarget>(),
        8usize,
        concat!("Alignment of ", stringify!(RecordTarget))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordTarget>())).kind as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTarget),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordTarget>())).endpoint as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTarget),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordTarget>())).device_num as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTarget),
            "::",
            stringify!(device_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordTarget>())).task_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTarget),
            "::",
            stringify!(task_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordTarget>())).target_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTarget),
            "::",
            stringify!(target_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordTarget>())).codeptr_ra as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTarget),
            "::",
            stringify!(codeptr_ra)
        )
    );
}
pub type CallbackTargetMapFn = Option<
    unsafe extern "C" fn(
        target_id: Id,
        nitems: c_uint,
        host_addr: *mut *mut c_void,
        device_addr: *mut *mut c_void,
        bytes: *mut usize,
        mapping_flags: *mut c_uint,
        codeptr_ra: *const c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecordTargetMap {
    pub target_id: Id,
    pub nitems: c_uint,
    pub host_addr: *mut *mut c_void,
    pub device_addr: *mut *mut c_void,
    pub bytes: *mut usize,
    pub mapping_flags: *mut c_uint,
    pub codeptr_ra: *const c_void,
}
#[test]
fn bindgen_test_layout_RecordTargetMap() {
    assert_eq!(
        ::std::mem::size_of::<RecordTargetMap>(),
        56usize,
        concat!("Size of: ", stringify!(RecordTargetMap))
    );
    assert_eq!(
        ::std::mem::align_of::<RecordTargetMap>(),
        8usize,
        concat!("Alignment of ", stringify!(RecordTargetMap))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordTargetMap>())).target_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTargetMap),
            "::",
            stringify!(target_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordTargetMap>())).nitems as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTargetMap),
            "::",
            stringify!(nitems)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordTargetMap>())).host_addr as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTargetMap),
            "::",
            stringify!(host_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordTargetMap>())).device_addr as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTargetMap),
            "::",
            stringify!(device_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordTargetMap>())).bytes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTargetMap),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordTargetMap>())).mapping_flags as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTargetMap),
            "::",
            stringify!(mapping_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordTargetMap>())).codeptr_ra as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTargetMap),
            "::",
            stringify!(codeptr_ra)
        )
    );
}
pub type CallbackTargetSubmitFn = Option<
    unsafe extern "C" fn(
        target_id: Id,
        host_op_id: Id,
        requested_num_teams: c_uint,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecordTargetKernel {
    pub host_op_id: Id,
    pub requested_num_teams: c_uint,
    pub granted_num_teams: c_uint,
    pub end_time: DeviceTime,
}
#[test]
fn bindgen_test_layout_RecordTargetKernel() {
    assert_eq!(
        ::std::mem::size_of::<RecordTargetKernel>(),
        24usize,
        concat!("Size of: ", stringify!(RecordTargetKernel))
    );
    assert_eq!(
        ::std::mem::align_of::<RecordTargetKernel>(),
        8usize,
        concat!("Alignment of ", stringify!(RecordTargetKernel))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordTargetKernel>())).host_op_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTargetKernel),
            "::",
            stringify!(host_op_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordTargetKernel>())).requested_num_teams as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTargetKernel),
            "::",
            stringify!(requested_num_teams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordTargetKernel>())).granted_num_teams as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTargetKernel),
            "::",
            stringify!(granted_num_teams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordTargetKernel>())).end_time as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordTargetKernel),
            "::",
            stringify!(end_time)
        )
    );
}
pub type CallbackControlToolFn = Option<
    unsafe extern "C" fn(
        command: u64,
        modifier: u64,
        arg: *mut c_void,
        codeptr_ra: *const c_void,
    ) -> c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecordControlTool {
    pub command: u64,
    pub modifier: u64,
    pub codeptr_ra: *const c_void,
}
#[test]
fn bindgen_test_layout_RecordControlTool() {
    assert_eq!(
        ::std::mem::size_of::<RecordControlTool>(),
        24usize,
        concat!("Size of: ", stringify!(RecordControlTool))
    );
    assert_eq!(
        ::std::mem::align_of::<RecordControlTool>(),
        8usize,
        concat!("Alignment of ", stringify!(RecordControlTool))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordControlTool>())).command as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordControlTool),
            "::",
            stringify!(command)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordControlTool>())).modifier as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordControlTool),
            "::",
            stringify!(modifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordControlTool>())).codeptr_ra as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordControlTool),
            "::",
            stringify!(codeptr_ra)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ompd_address_t {
    pub segment: ompd_seg_t,
    pub address: ompd_addr_t,
}
#[test]
fn bindgen_test_layout_ompd_address_t() {
    assert_eq!(
        ::std::mem::size_of::<ompd_address_t>(),
        16usize,
        concat!("Size of: ", stringify!(ompd_address_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ompd_address_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ompd_address_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ompd_address_t>())).segment as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ompd_address_t),
            "::",
            stringify!(segment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ompd_address_t>())).address as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ompd_address_t),
            "::",
            stringify!(address)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ompd_frame_info_t {
    pub frame_address: ompd_address_t,
    pub frame_flag: ompd_word_t,
}
#[test]
fn bindgen_test_layout_ompd_frame_info_t() {
    assert_eq!(
        ::std::mem::size_of::<ompd_frame_info_t>(),
        24usize,
        concat!("Size of: ", stringify!(ompd_frame_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ompd_frame_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ompd_frame_info_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ompd_frame_info_t>())).frame_address as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ompd_frame_info_t),
            "::",
            stringify!(frame_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ompd_frame_info_t>())).frame_flag as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ompd_frame_info_t),
            "::",
            stringify!(frame_flag)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ompd_aspace_handle {
    _unused: [u8; 0],
}
pub type ompd_address_space_handle_t = _ompd_aspace_handle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ompd_thread_handle {
    _unused: [u8; 0],
}
pub type ompd_thread_handle_t = _ompd_thread_handle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ompd_parallel_handle {
    _unused: [u8; 0],
}
pub type ompd_parallel_handle_t = _ompd_parallel_handle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ompd_task_handle {
    _unused: [u8; 0],
}
pub type ompd_task_handle_t = _ompd_task_handle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ompd_aspace_cont {
    _unused: [u8; 0],
}
pub type ompd_address_space_context_t = _ompd_aspace_cont;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ompd_thread_cont {
    _unused: [u8; 0],
}
pub type ompd_thread_context_t = _ompd_thread_cont;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ompd_device_type_sizes_t {
    pub sizeof_char: u8,
    pub sizeof_short: u8,
    pub sizeof_int: u8,
    pub sizeof_long: u8,
    pub sizeof_long_long: u8,
    pub sizeof_pointer: u8,
}
#[test]
fn bindgen_test_layout_ompd_device_type_sizes_t() {
    assert_eq!(
        ::std::mem::size_of::<ompd_device_type_sizes_t>(),
        6usize,
        concat!("Size of: ", stringify!(ompd_device_type_sizes_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ompd_device_type_sizes_t>(),
        1usize,
        concat!("Alignment of ", stringify!(ompd_device_type_sizes_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ompd_device_type_sizes_t>())).sizeof_char as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ompd_device_type_sizes_t),
            "::",
            stringify!(sizeof_char)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ompd_device_type_sizes_t>())).sizeof_short as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ompd_device_type_sizes_t),
            "::",
            stringify!(sizeof_short)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ompd_device_type_sizes_t>())).sizeof_int as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ompd_device_type_sizes_t),
            "::",
            stringify!(sizeof_int)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ompd_device_type_sizes_t>())).sizeof_long as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(ompd_device_type_sizes_t),
            "::",
            stringify!(sizeof_long)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ompd_device_type_sizes_t>())).sizeof_long_long as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ompd_device_type_sizes_t),
            "::",
            stringify!(sizeof_long_long)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ompd_device_type_sizes_t>())).sizeof_pointer as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(ompd_device_type_sizes_t),
            "::",
            stringify!(sizeof_pointer)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RecordOmpt {
    pub type_: Callbacks,
    pub time: DeviceTime,
    pub thread_id: Id,
    pub target_id: Id,
    pub record: RecordOmptTBindgenTy1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RecordOmptTBindgenTy1 {
    pub thread_begin: RecordThreadBegin,
    pub parallel_begin: RecordParallelBegin,
    pub parallel_end: RecordParallelEnd,
    pub work: RecordWork,
    pub dispatch: RecordDispatch,
    pub task_create: RecordTaskCreate,
    pub dependences: RecordDependences,
    pub task_dependence: RecordTaskDependence,
    pub task_schedule: RecordTaskSchedule,
    pub implicit_task: RecordImplicitTask,
    pub master: RecordMaster,
    pub sync_region: RecordSyncRegion,
    pub mutex_acquire: RecordMutexAcquire,
    pub mutex: RecordMutex,
    pub nest_lock: RecordNestLock,
    pub flush: RecordFlush,
    pub cancel: RecordCancel,
    pub target: RecordTarget,
    pub target_data_op: RecordTargetDataOp,
    pub target_map: RecordTargetMap,
    pub target_kernel: RecordTargetKernel,
    pub control_tool: RecordControlTool,
    _bindgen_union_align: [u64; 9usize],
}
#[test]
fn bindgen_test_layout_RecordOmptTBindgenTy1() {
    assert_eq!(
        ::std::mem::size_of::<RecordOmptTBindgenTy1>(),
        72usize,
        concat!("Size of: ", stringify!(RecordOmptTBindgenTy1))
    );
    assert_eq!(
        ::std::mem::align_of::<RecordOmptTBindgenTy1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RecordOmptTBindgenTy1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordOmptTBindgenTy1>())).thread_begin as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordOmptTBindgenTy1),
            "::",
            stringify!(thread_begin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordOmptTBindgenTy1>())).parallel_begin as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordOmptTBindgenTy1),
            "::",
            stringify!(parallel_begin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordOmptTBindgenTy1>())).parallel_end as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordOmptTBindgenTy1),
            "::",
            stringify!(parallel_end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordOmptTBindgenTy1>())).work as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordOmptTBindgenTy1),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordOmptTBindgenTy1>())).dispatch as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordOmptTBindgenTy1),
            "::",
            stringify!(dispatch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordOmptTBindgenTy1>())).task_create as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordOmptTBindgenTy1),
            "::",
            stringify!(task_create)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordOmptTBindgenTy1>())).dependences as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordOmptTBindgenTy1),
            "::",
            stringify!(dependences)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordOmptTBindgenTy1>())).task_dependence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordOmptTBindgenTy1),
            "::",
            stringify!(task_dependence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordOmptTBindgenTy1>())).task_schedule as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordOmptTBindgenTy1),
            "::",
            stringify!(task_schedule)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordOmptTBindgenTy1>())).implicit_task as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordOmptTBindgenTy1),
            "::",
            stringify!(implicit_task)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordOmptTBindgenTy1>())).master as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordOmptTBindgenTy1),
            "::",
            stringify!(master)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordOmptTBindgenTy1>())).sync_region as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordOmptTBindgenTy1),
            "::",
            stringify!(sync_region)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordOmptTBindgenTy1>())).mutex_acquire as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordOmptTBindgenTy1),
            "::",
            stringify!(mutex_acquire)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordOmptTBindgenTy1>())).mutex as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordOmptTBindgenTy1),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordOmptTBindgenTy1>())).nest_lock as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordOmptTBindgenTy1),
            "::",
            stringify!(nest_lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordOmptTBindgenTy1>())).flush as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordOmptTBindgenTy1),
            "::",
            stringify!(flush)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordOmptTBindgenTy1>())).cancel as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordOmptTBindgenTy1),
            "::",
            stringify!(cancel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordOmptTBindgenTy1>())).target as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordOmptTBindgenTy1),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordOmptTBindgenTy1>())).target_data_op as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordOmptTBindgenTy1),
            "::",
            stringify!(target_data_op)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordOmptTBindgenTy1>())).target_map as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordOmptTBindgenTy1),
            "::",
            stringify!(target_map)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordOmptTBindgenTy1>())).target_kernel as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordOmptTBindgenTy1),
            "::",
            stringify!(target_kernel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RecordOmptTBindgenTy1>())).control_tool as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordOmptTBindgenTy1),
            "::",
            stringify!(control_tool)
        )
    );
}
#[test]
fn bindgen_test_layout_RecordOmpt() {
    assert_eq!(
        ::std::mem::size_of::<RecordOmpt>(),
        104usize,
        concat!("Size of: ", stringify!(RecordOmpt))
    );
    assert_eq!(
        ::std::mem::align_of::<RecordOmpt>(),
        8usize,
        concat!("Alignment of ", stringify!(RecordOmpt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordOmpt>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordOmpt),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordOmpt>())).time as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordOmpt),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordOmpt>())).thread_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordOmpt),
            "::",
            stringify!(thread_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordOmpt>())).target_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordOmpt),
            "::",
            stringify!(target_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RecordOmpt>())).record as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordOmpt),
            "::",
            stringify!(record)
        )
    );
}
pub type GetRecordOmpt = Option<
    unsafe extern "C" fn(
        buffer: *mut Buffer,
        current: BufferCursor,
    ) -> *mut RecordOmpt,
>;
